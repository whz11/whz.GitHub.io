---
layout:     post                    # 使用的布局（不需要改）
title:      DFS(深度优先搜索)               # 标题 
subtitle:   算法理解＋实例            #副标题
date:       2020-03-09              # 时间
author:     BY whz（转）                    # 作者
header-img: img/post-bg-2015.jpg    #这篇文章标题背景图片
catalog: true                       # 是否归档
tags:                               #标签
    - 算法
---


# DFS(深度优先搜索)



深度优先搜索算法（英语：Depth-First-Search，简称DFS）是一种用于遍历或搜索树或图的算法。 沿着树的深度遍历树的节点，尽可能深的搜索树的分支。当节点v的所在边都己被探寻过或者在搜寻时结点不满足条件，搜索将回溯到发现节点v的那条边的起始节点。整个进程反复进行直到所有节点都被访问为止。属于盲目搜索,最糟糕的情况算法时间复杂度为O(!n)。（Wiki）

```c
//A - Oil Deposits 
#include<stdio.h>
#include<string.h>
#include<stdlib.h>

char a[105][105];
int n,m,result;
int dir[8][2]={{1,0},{-1,0},{0,1},{0,-1},{1,1},{-1,-1},{1,-1},{-1,1}};//表示8个方向

int check(int x,int y)//检查是否有油田
{
    if(x>=0&&x<m&&y>=0&&y<n&&a[x][y]=='@')
        return 1;
    return 0;
}

int dfs(int x, int y)
{
    int i,xx,yy;
    if(check(x,y))
    {
        a[x][y]='.'; //统计之后就可以把该油田标记，且不用恢复（要不会重复），
                    //也可以用一个数组来存每个点的访问情况，但是感觉没必要，浪费空间
        for(i=0;i<8;i++)
        {
            xx=x+dir[i][0];
            yy=y+dir[i][1];
            dfs(xx,yy);//依次检查8个方向
        }
        return 1;
    }
    return 0;
}

int main(void)
{
    int i,j;
    while(scanf("%d %d",&m,&n)==2)
    {
        if(m==0&&n==0)
            break;
        result = 0;
        memset(a,0,sizeof(a));
        for(i=0;i<m;i++)
            scanf("%s",a[i]);
        for(i=0;i<m;i++)//在每一个点都搜索一次
        {
            for(j=0;j<n;j++)
            {
                if(dfs(i,j))//找到油田就可以将结果加1
                    result++;
            }
        }
        printf("%d\n",result);
    }
    return 0;
}
```

4、棋盘问题
问题：在一个给定形状的棋盘（形状可能是不规则的）上面摆放棋子，棋子没有区别。要求摆放时任意的两个棋子不能放在棋盘中的同一行或者同一列，请编程求解对于给定形状和大小的棋盘，摆放k个棋子的所有可行的摆放方案C。

input： 输入含有多组测试数据。 每组数据的第一行是两个正整数，n k，用一个空格隔开，表示了将在一个n*n的矩阵内描述棋盘，以及摆放棋子的数目。 n <= 8 , k <= n 当为-1 -1时表示输入结束。 随后的n行描述了棋盘的形状：每行有n个字符，其中 # 表示棋盘区域， . 表示空白区域（数据保证不出现多余的空白行或者空白列）。

output：对于每一组数据，给出一行输出，输出摆放的方案数目C （数据保证C<2^31）。

```c
#include<stdio.h>
#include<string.h>
#include<stdlib.h>

int n, k, ans;
char str[10][10];
int vis[100];

void dfs(int r, int k)
{
    if(k==0)//判断边界，此时棋子已经放完
    {
        ans++;
        return;
    }

    for(int i=r; i<n; i++)//每次都从放过棋子下一行开始搜索，保证不重复
    {
        for(int j=0; j<n; j++)
        {
            //循环保证行不重复，check保证列不重复
            if(str[i][j]=='.' || vis[j]==1)
                continue;//不满足条件直接跳过
            vis[j] = 1;//标记
            dfs(i+1, k-1);//继续下一次标记
            vis[j] = 0;//恢复初始状态
        }
    }
}

int main(void)
{
    while(1)
    {
        scanf("%d %d", &n, &k);
        getchar();
        if(n==-1 && k==-1) 
            break;
        memset(str, '\0', sizeof(str));
        memset(vis, 0, sizeof(vis));
        ans = 0;

        for(int i=0; i<n; i++)
        {
            for(int j=0; j<n; j++)
                str[i][j] = getchar();
            getchar();
        }

        dfs(0, k);//从第0行开始放，此时手中还剩k个棋子
        printf("%d\n", ans);
    }
    return 0;
}

```

总结一下，用递归法来实现DFS，比较好理解，就一直往下找，知道走不通后在回来尝试其它的地方。一个DFS一般要判断边界，check来判断是否符合相应条件，vis或者book来记录是否已经被用过，递归进行下一步操作。有的时候我们要将标记过的点恢复原来的状态，有时候则不必要恢复(油田问题)，要结合具体的问题来分析。

恢复标记相当于回溯的思想。
回溯法（探索与回溯法）是一种选优搜索法，又称为试探法，按选优条件向前搜索，以达到目标。但当探索到某一步时，发现原先选择并不优或达不到目标，就退回一步重新选择，这种走不通就退回再走的技术为回溯法，而满足回溯条件的某个状态的点称为“回溯点”。
